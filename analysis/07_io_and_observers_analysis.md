# I/O and Observers Analysis

## Part 1: I/O Module

### Overview

The `io/` module handles file formats for pose graph optimization.

**Files:**
- `mod.rs` - Data structures, `GraphLoader` trait (~490 LOC)
- `g2o.rs` - G2O format support (~558 LOC)
- `toro.rs` - TORO format support (~142 LOC)

### Data Structures

**Location:** `src/io/mod.rs`

#### Graph Structure

```rust
pub struct Graph {
    pub vertices_se2: HashMap<usize, VertexSE2>,
    pub vertices_se3: HashMap<usize, VertexSE3>,
    pub edges_se2: Vec<EdgeSE2>,
    pub edges_se3: Vec<EdgeSE3>,
}
```

#### Vertex Types

```rust
pub struct VertexSE2 {
    pub id: usize,
    pub pose: SE2,
}

pub struct VertexSE3 {
    pub id: usize,
    pub pose: SE3,
}
```

#### Edge Types

```rust
pub struct EdgeSE2 {
    pub id_from: usize,
    pub id_to: usize,
    pub measurement: SE2,
    pub information: Matrix3<f64>,
}

pub struct EdgeSE3 {
    pub id_from: usize,
    pub id_to: usize,
    pub measurement: SE3,
    pub information: Matrix6<f64>,
}
```

### GraphLoader Trait

**Location:** `src/io/mod.rs:352-359`

```rust
pub trait GraphLoader {
    fn load<P: AsRef<Path>>(path: P) -> IoResult<Graph>;
    fn write<P: AsRef<Path>>(path: P, graph: &Graph) -> IoResult<()>;
}
```

### G2O Format Implementation

**Location:** `src/io/g2o.rs`

#### Memory-Mapped Loading

```rust
impl GraphLoader for G2oLoader {
    fn load<P: AsRef<Path>>(path: P) -> IoResult<Graph> {
        // Memory-mapped file for zero-copy access
        let file = File::open(&path)?;
        let mmap = unsafe { memmap2::Mmap::map(&file)? };
        let content = std::str::from_utf8(&mmap)?;
        
        // Adaptive parsing based on file size
        let line_count = content.lines().count();
        if line_count < 1000 {
            parse_sequential(content)
        } else {
            parse_parallel(content)
        }
    }
}
```

#### Parallel Parsing (Large Files)

**Location:** Lines 193-224

```rust
fn parse_parallel(content: &str) -> IoResult<Graph> {
    let parsed_items: Vec<ParsedItem> = content
        .par_lines()
        .enumerate()
        .filter_map(|(line_num, line)| {
            parse_line_to_enum(line, line_num).transpose()
        })
        .collect::<Result<Vec<_>, _>>()?;
    
    // Sequential insertion (avoid concurrent HashMap modification)
    let mut graph = Graph::new();
    for item in parsed_items {
        match item {
            ParsedItem::VertexSE2(v) => {
                if graph.vertices_se2.contains_key(&v.id) {
                    return Err(IoError::DuplicateVertex(v.id));
                }
                graph.vertices_se2.insert(v.id, v);
            }
            // ... other variants
        }
    }
    Ok(graph)
}
```

#### Line Parsing

```rust
fn parse_vertex_se3(line: &str, line_num: usize) -> IoResult<VertexSE3> {
    // VERTEX_SE3:QUAT id tx ty tz qx qy qz qw
    let parts: Vec<&str> = line.split_whitespace().collect();
    
    if parts.len() != 9 {
        return Err(IoError::MissingFields { 
            line: line_num, 
            expected: 9, 
            found: parts.len() 
        });
    }
    
    let id: usize = parts[1].parse()?;
    let tx: f64 = parts[2].parse()?;
    // ... parse ty, tz, qx, qy, qz, qw
    
    // Quaternion validation
    let quat_norm = (qx*qx + qy*qy + qz*qz + qw*qw).sqrt();
    if (quat_norm - 1.0).abs() > 0.01 {
        return Err(IoError::InvalidQuaternion { 
            line: line_num, 
            norm: quat_norm 
        });
    }
    
    Ok(VertexSE3 { id, pose: SE3::from_parts(translation, rotation) })
}
```

#### G2O Writing

**Location:** Lines 40-91

```rust
fn write<P: AsRef<Path>>(path: P, graph: &Graph) -> IoResult<()> {
    let mut file = File::create(&path)?;
    
    // Header
    writeln!(file, "# Generated by Apex Solver")?;
    writeln!(file, "# Vertices: {} SE2, {} SE3", 
        graph.vertices_se2.len(), graph.vertices_se3.len())?;
    
    // Sorted vertices for reproducibility
    let mut se3_ids: Vec<_> = graph.vertices_se3.keys().collect();
    se3_ids.sort();
    
    for id in se3_ids {
        let v = &graph.vertices_se3[id];
        let t = v.pose.translation();
        let q = v.pose.quaternion();
        writeln!(file, "VERTEX_SE3:QUAT {} {:.17e} {:.17e} {:.17e} {:.17e} {:.17e} {:.17e} {:.17e}",
            id, t.x, t.y, t.z, q.i, q.j, q.k, q.w)?;
    }
    
    // Edges with upper triangular information matrix
    // ... similar pattern
    
    Ok(())
}
```

### TORO Format Implementation

**Location:** `src/io/toro.rs`

SE2-only format (legacy 2D SLAM):
```
VERTEX2 id x y theta
EDGE2 from to dx dy dtheta i11 i12 i22 i33 i13 i23
```

Returns error if SE3 data present.

### Error Handling

**Location:** `src/io/mod.rs:30-57`

```rust
#[derive(Debug, Clone, Error)]
pub enum IoError {
    #[error("Parse error at line {line}: {message}")]
    ParseError { line: usize, message: String },
    
    #[error("Unsupported vertex type: {0}")]
    UnsupportedVertexType(String),
    
    #[error("Invalid number format at line {line}: {0}")]
    InvalidNumberFormat { line: usize, source: String },
    
    #[error("Missing fields at line {line}: expected {expected}, found {found}")]
    MissingFields { line: usize, expected: usize, found: usize },
    
    #[error("Duplicate vertex ID: {0}")]
    DuplicateVertex(usize),
    
    #[error("Invalid quaternion at line {line}: norm = {norm:.6}")]
    InvalidQuaternion { line: usize, norm: f64 },
}
```

### Convenience Function

**Location:** `src/io/mod.rs:361-379`

```rust
pub fn load_graph<P: AsRef<Path>>(path: P) -> IoResult<Graph> {
    let path = path.as_ref();
    let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
    
    match ext {
        "g2o" => G2oLoader::load(path),
        "graph" => ToroLoader::load(path),
        _ => Err(IoError::UnsupportedFormat(ext.to_string())),
    }
}
```

---

## Part 2: Observers Module

### Overview

The `observers/` module provides optimization monitoring and visualization.

**Files:**
- `mod.rs` - `OptObserver` trait (~398 LOC)
- `visualization.rs` - Rerun integration (~750 LOC) [feature-gated]
- `conversions.rs` - Type conversions (~297 LOC) [feature-gated]

### OptObserver Trait

**Location:** `src/observers/mod.rs:110-189`

```rust
pub trait OptObserver: Send {
    /// Called at each optimization iteration
    fn on_step(&self, values: &HashMap<String, VariableEnum>, iteration: usize);
    
    /// Set iteration metrics (optional)
    fn set_iteration_metrics(
        &mut self, 
        cost: f64, 
        gradient_norm: f64, 
        damping: f64, 
        step_norm: f64, 
        step_quality: f64
    ) {
        // Default: no-op
    }
    
    /// Set matrix data for visualization (optional)
    fn set_matrix_data(
        &mut self,
        hessian: Option<&SparseColMat<usize, f64>>,
        gradient: Option<&Mat<f64>>
    ) {
        // Default: no-op
    }
}
```

### OptObserverVec

**Location:** `src/observers/mod.rs:191-320`

```rust
pub struct OptObserverVec {
    observers: Vec<Box<dyn OptObserver>>,
}

impl OptObserverVec {
    pub fn new() -> Self {
        Self { observers: Vec::new() }
    }
    
    pub fn add(&mut self, observer: Box<dyn OptObserver>) {
        self.observers.push(observer);
    }
    
    #[inline(always)]  // Zero overhead when empty
    pub fn notify(&self, values: &HashMap<String, VariableEnum>, iteration: usize) {
        for observer in &self.observers {
            observer.on_step(values, iteration);
        }
    }
    
    pub fn set_iteration_metrics(&mut self, cost: f64, ...) {
        for observer in &mut self.observers {
            observer.set_iteration_metrics(cost, ...);
        }
    }
}
```

### RerunObserver (Feature-Gated)

**Location:** `src/observers/visualization.rs`

```rust
#[cfg(feature = "visualization")]
pub struct RerunObserver {
    rec: Option<rerun::RecordingStream>,
    enabled: bool,
    iteration_metrics: RefCell<IterationMetrics>,
}
```

#### Initialization

```rust
impl RerunObserver {
    pub fn new(enabled: bool) -> Self {
        Self::new_with_options(enabled, None)
    }
    
    pub fn new_with_options(enabled: bool, save_path: Option<&str>) -> Self {
        if !enabled {
            return Self { rec: None, enabled: false, ... };
        }
        
        let rec = if let Some(path) = save_path {
            // Save to file
            rerun::RecordingStreamBuilder::new("apex_solver")
                .save(path)
                .ok()
        } else {
            // Try to spawn viewer
            rerun::RecordingStreamBuilder::new("apex_solver")
                .spawn()
                .ok()
                .or_else(|| {
                    // Fallback to temp file
                    warn!("Could not spawn Rerun viewer, saving to temp file");
                    rerun::RecordingStreamBuilder::new("apex_solver")
                        .save("/tmp/apex_solver.rrd")
                        .ok()
                })
        };
        
        Self { rec, enabled, ... }
    }
}
```

#### Logging Methods

```rust
impl RerunObserver {
    fn log_scalars(&self, iteration: usize) {
        if let Some(ref rec) = self.rec {
            let metrics = self.iteration_metrics.borrow();
            
            rec.set_time_sequence("iteration", iteration as i64);
            rec.log("cost_plot/value", &rerun::Scalar::new(metrics.cost));
            rec.log("gradient_plot/norm", &rerun::Scalar::new(metrics.gradient_norm));
            rec.log("damping_plot/lambda", &rerun::Scalar::new(metrics.damping));
        }
    }
    
    fn log_manifolds(&self, values: &HashMap<String, VariableEnum>) {
        if let Some(ref rec) = self.rec {
            for (name, var) in values {
                match var {
                    VariableEnum::SE3(v) => {
                        let transform: Transform3D = v.get_value().into();
                        rec.log(format!("poses/{}", name), &transform);
                    }
                    VariableEnum::SE2(v) => {
                        let transform: Transform3D = v.get_value().into();
                        rec.log(format!("poses/{}", name), &transform);
                    }
                    _ => {}
                }
            }
        }
    }
}
```

#### Matrix Visualization

**Location:** Lines 512-675

```rust
fn sparse_hessian_to_image(hessian: &SparseColMat<usize, f64>) -> TensorData {
    // Downsample to 100x100 for visualization
    let target_size = 100;
    let block_size = hessian.nrows().div_ceil(target_size);
    
    // Block averaging
    let mut image = vec![vec![[255u8, 255, 255]; target_size]; target_size];
    
    for col in 0..hessian.ncols() {
        for (row, &val) in hessian.col(col).iter() {
            let i = row / block_size;
            let j = col / block_size;
            // Accumulate values
        }
    }
    
    // Convert to RGB heatmap
    for i in 0..target_size {
        for j in 0..target_size {
            image[i][j] = value_to_rgb_heatmap(values[i][j], min_val, max_val);
        }
    }
    
    TensorData::new(image)
}

fn value_to_rgb_heatmap(value: f64, min: f64, max: f64) -> [u8; 3] {
    if !value.is_finite() || value == 0.0 {
        return [255, 255, 255];  // White for zero/invalid
    }
    
    let t = (value - min) / (max - min);
    let blue = (t * 255.0) as u8;
    [255 - blue, 255 - blue, 255]  // White to blue gradient
}
```

### Type Conversions

**Location:** `src/observers/conversions.rs`

```rust
#[cfg(feature = "visualization")]
impl From<&SE3> for Transform3D {
    fn from(se3: &SE3) -> Self {
        let t = se3.translation();
        let q = se3.quaternion();
        
        Transform3D::from_translation_rotation(
            Vec3::new(t.x as f32, t.y as f32, t.z as f32),
            Quat::from_xyzw(q.i as f32, q.j as f32, q.k as f32, q.w as f32),
        )
    }
}

impl From<&SE2> for Transform3D {
    fn from(se2: &SE2) -> Self {
        let pos = se2.translation();
        let angle = se2.angle();
        let half_angle = angle / 2.0;
        
        Transform3D::from_translation_rotation(
            Vec3::new(pos.x as f32, pos.y as f32, 0.0),
            Quat::from_xyzw(0.0, 0.0, half_angle.sin() as f32, half_angle.cos() as f32),
        )
    }
}

// Batch conversions
impl FromIterator<&SE3> for Points3D {
    fn from_iter<I: IntoIterator<Item = &SE3>>(iter: I) -> Self {
        Points3D::new(
            iter.into_iter()
                .map(|se3| se3.translation())
                .map(|t| Vec3::new(t.x as f32, t.y as f32, t.z as f32))
        )
    }
}
```

---

## Part 3: Supporting Files

### lib.rs

**Location:** `src/lib.rs`

```rust
pub mod core;
pub mod error;
pub mod factors;
pub mod io;
pub mod linalg;
pub mod logger;
pub mod manifold;
pub mod observers;
pub mod optimizer;

// Re-exports for convenient API
pub use core::variable::Variable;
pub use error::{ApexSolverError, ApexSolverResult};
// ... more re-exports
```

### error.rs (Top-Level Error)

**Location:** `src/error.rs`

```rust
#[derive(Debug, Error)]
pub enum ApexSolverError {
    #[error(transparent)]
    Core(#[from] CoreError),
    
    #[error(transparent)]
    Optimizer(#[from] OptimizerError),
    
    #[error(transparent)]
    LinearAlgebra(#[from] LinAlgError),
    
    #[error(transparent)]
    Manifold(#[from] ManifoldError),
    
    #[error(transparent)]
    Io(#[from] IoError),
    
    #[error(transparent)]
    Observer(#[from] ObserverError),
}

impl ApexSolverError {
    /// Format error chain with arrows
    pub fn chain(&self) -> String {
        let mut result = self.to_string();
        let mut source = self.source();
        while let Some(s) = source {
            result.push_str(&format!("\n  â†’ {}", s));
            source = s.source();
        }
        result
    }
}
```

### logger.rs

**Location:** `src/logger.rs`

```rust
pub fn init_logger() {
    init_logger_with_level(Level::INFO);
}

pub fn init_logger_with_level(level: Level) {
    let filter = EnvFilter::from_default_env()
        .add_directive(level.into());
    
    tracing_subscriber::fmt()
        .with_env_filter(filter)
        .with_target(false)
        .event_format(CustomFormatter)
        .init();
}

struct CustomFormatter;

impl<S, N> FormatEvent<S, N> for CustomFormatter {
    fn format_event(&self, ...) -> fmt::Result {
        let color = match *meta.level() {
            Level::ERROR => "\x1b[31m",  // Red
            Level::WARN  => "\x1b[33m",  // Yellow
            Level::INFO  => "\x1b[32m",  // Green
            Level::DEBUG => "\x1b[34m",  // Blue
            Level::TRACE => "\x1b[35m",  // Magenta
        };
        
        write!(writer, "[{}{} {} {}{}] ", 
            color, meta.level(), timestamp, module, "\x1b[0m")?;
        // ... format message
    }
}
```

---

## Code Quality Summary

### I/O Module

| Aspect | Rating | Notes |
|--------|--------|-------|
| Error Handling | Excellent | Line numbers, descriptive errors |
| Performance | Excellent | Memory-mapped, parallel parsing |
| Validation | Good | Quaternion norm checking |
| Format Support | Good | G2O and TORO |

### Observers Module

| Aspect | Rating | Notes |
|--------|--------|-------|
| Design | Excellent | Clean trait abstraction |
| Feature Gating | Excellent | Visualization optional |
| Rerun Integration | Very Good | Comprehensive logging |
| Performance | Good | `#[inline(always)]` on notify |

### Recommendations

1. **I/O Edge Validation**: Verify edge vertex IDs exist
2. **More File Formats**: Consider BAL, Venice formats
3. **Observer Composition**: Tuple-based compile-time observers
4. **Streaming Parser**: For very large files (>1GB)
